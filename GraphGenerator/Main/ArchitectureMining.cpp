#pragma warning(disable : 4996)
#pragma warning(disable : 4146)
#include <iostream>
#include <fstream>
#include "SourceLoader.h"
#include "DependenciesMining.h"
#include "GraphGeneration.h"
#include "GraphToJson.h"
#include "json/writer.h"
#include "ImportST.h"
#include "LoadGlobalCache.h"

static void PrintMainArgInfo(void) {
	std::cout << "MAIN ARGUMENTS:\n\n";
	std::cout << "argv[1]: \"--src\" to mine whole directory with sources (argv[2]: directory/with/sources)\n";
	std::cout << "argv[1]: \"--cmp-db\" to use compilation database (argv[2]: path/to/compile_commands.json)\n";
	std::cout << "argv[3]: (file path) path/to/ignoredFilePaths\n";
	std::cout << "argv[4]: (file path) path/to/ignoredNamespaces\n";
	std::cout << "argv[5]: (file path) path/to/ST-output\n";
}

static void SetDepedenciesToST(const Json::Value& graph, Json::Value& ST) {
	const Json::Value& all_dependencies = graph["edges"];
	auto& st_dependencies = ST["dependencies"];
	for (const auto& dependencies : all_dependencies) {

		Json::Value dependency_pack;
		dependency_pack["types"] = dependencies["dependencies"];
		dependency_pack["from"] = dependencies["from"];
		dependency_pack["to"] = dependencies["to"];

		st_dependencies.append(dependency_pack);
	}
}

static void SetCodeFilesToST(Json::Value& ST, const std::vector<std::string>& srcs, const std::vector<std::string>& headers) {
	for (const auto& path : srcs) {
		ST["sources"].append(path);
	}
	for (const auto& path : headers) {
		ST["headers"].append(path);
	}
}

int main(int argc, char const* argv[]) {
	if (argc < 6) {
		PrintMainArgInfo();
		return 1;
	}

#ifdef INCREMENTAL_GENERATION
	try {
		incremental::ImportStashedST(argv[5], dependenciesMining::structuresTable);

		incremental::LoadGlobalCache(dependenciesMining::structuresTable, dependenciesMining::cache);

	}
	catch (const Json::RuntimeError&) {
		std::cerr << "INVALID OUTPUT PATH\n\n"
			"Make sure that either there is no .json out file, "
			"or the .json out file was generated by mining with the INCREMENTAL_GENERATION flag enabled\n";

		return EXIT_FAILURE;
	}
#endif

	std::string option1 = "--src";
	std::string option2 = "--cmp-db";
	const char* cmpDBPath = nullptr;
	std::vector<std::string> srcs;
	std::vector<std::string> headers;
	if (option1 == argv[1]) { // --src
		sourceLoader::SourceLoader srcLoader(argv[2]);
		srcLoader.LoadSources();
		srcs = srcLoader.GetSources();
	}
	else if (option2 == argv[1]) { //--cmp-db
		cmpDBPath = argv[2];
	}
	else {
		PrintMainArgInfo();
		return 1;
	}
	const char* option = argv[1]; // option = "--src", option = "--cmp-db"

	const char* ignoredFilePaths = argv[3];
	const char* ignoredNamespaces = argv[4];

	std::string jsonSTPath = argv[5];
	std::cout << "\n-------------------------------------------------------------------------------------\n\n";
	int result = dependenciesMining::CreateClangTool(cmpDBPath, srcs, headers, ignoredFilePaths, ignoredNamespaces);

	Json::Value json_ST;
	structuresTable.AddJsonSymbolTable(json_ST["structures"]);
	std::ofstream jsonSTFile(jsonSTPath);

	graph::Graph graph = graphGeneration::GenetareDependenciesGraph(dependenciesMining::structuresTable);
	auto g = graphToJson::GetJson(graph);
	SetDepedenciesToST(g, json_ST);
	SetCodeFilesToST(json_ST, srcs, headers);
	jsonSTFile << json_ST;
	jsonSTFile.close();

	std::cout << "\nCOMPILATION FINISHED\n";
}